"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var clone = require("clone");
var dtsmake;
(function (dtsmake) {
    var DTS_INTERFACE_STR = "!!!dtsinterface!!!";
    var DTS_NAMESPACE_STR = "!!!dtsnamespace!!!";
    var DTSMake = (function () {
        function DTSMake() {
            /**
             * Default Options
             */
            this.option = {
                // debug mode
                isDebug: false,
                // force output "void" to "any"
                isOutVoidAsAny: false,
                // export a namespace property same with a interface 
                isExportInterfaceSameNameVar: true,
                // annotate interface constructor type as return type instance
                isAnnotateTypeInstance: true,
                // node module special replace
                isNodeJsModule: false,
                // add export statement in a bottom of d.ts file
                isOutExport: true,
                // how to export objects that has same name with JS global object
                globalObject: dtsmake.Option.GlobalObject.WRAP,
                // if isOutExport true, select export style "es6" or "legacy"
                exportStyle: dtsmake.Option.ExportStyle.LEGACY,
                // exporting module name
                // ex. "EXAMPLE"; usage 'import example = require("EXAMPLE");'
                // ex. "EXAMPLE/lib"; usage 'import example = require("EXAMPLE/lib");'
                // check javascript lib's import style
                exportModuleName: ""
            };
            this.modJson = {};
            this.isInDefine = false;
            this.isNodeJsModule = false;
            this.isInClassOrInterface = false;
            this.isInObjectLiteral = false;
            this.isNeedDeclare = true;
            this.depth = 0;
        }
        DTSMake.prototype.main = function (param1, distPathStr, options) {
            var _this = this;
            this.overrideDefaultOptions(options);
            if (/\n/.test(param1)) {
                //source code text
                var s = this.parseTernJson(JSON.parse(param1), distPathStr);
                this.saveTSDFile(distPathStr, s);
            }
            else if (/\.json$/.test(param1)) {
                //src json path
                this.loadTernJson(param1, function (data) {
                    var s = _this.parseTernJson(data, distPathStr);
                    _this.saveTSDFile(distPathStr, s);
                });
            }
        };
        DTSMake.prototype.overrideDefaultOptions = function (options) {
            if (options) {
                for (var i in options) {
                    if (this.option[i] !== undefined || this.option[i] !== null) {
                        //override default options
                        this.option[i] = options[i];
                    }
                }
            }
        };
        /**
         * load ternjs json format data
         * @param pathStr path/to/file/example.json, must be strings
         */
        DTSMake.prototype.loadTernJson = function (pathStr, cb) {
            var _this = this;
            fs.readFile(pathStr, "UTF-8", function (err, data) {
                if (err)
                    throw Error(err.name + " " + err.code + " " + err.message + " " + err.path);
                _this.ternjsData = JSON.parse(data.toString());
                //console.log(JSON.stringify(this.ternjsData));
                console.log("Load a JSON file complete.");
                //this.parseTernJson(this.ternjsData);
                cb(_this.ternjsData);
            });
        };
        /**
         * save typescript d.ts file.
         * TODO: add line feed option (LF/CR/CR-LF)
         * @param name path/to/filename, no need file ext. like ".d.ts"
         * @param src file data strings.
         */
        DTSMake.prototype.saveTSDFile = function (name, src) {
            try {
                fs.writeFile(name + ".d.ts", src, { encoding: "UTF-8" }, function (err) {
                    if (err)
                        throw Error(err.name + " " + err.code + " " + err.message + " " + err.path);
                    console.log("File saved. (" + name + ".d.ts)");
                });
            }
            catch (e) {
                throw Error(e);
                //return false;
            }
            return true;
        };
        DTSMake.prototype.saveJSON = function (pathStr, data, complete) {
            fs.writeFile(pathStr, data, { encoding: "UTF-8" }, function (e) {
                if (e)
                    throw Error(e.name + " " + e.code + " " + e.message + " " + e.path);
                complete();
            });
        };
        DTSMake.prototype.parseTernJson = function (data, distPathStr) {
            this.depth = 0;
            var o = this.parseJsonNodeDTS(data);
            //console.info("-----------------------");
            //console.log(JSON.stringify(o));
            var d = this.preModifiedJson(o);
            //console.info("-----------------------");
            //console.log(JSON.stringify(d));
            if (this.option.isOutExport &&
                this.userDefinedModuleName &&
                this.option.isNodeJsModule) {
                d = this.replaceExportNamespace(d);
            }
            if (this.option.isDebug) {
                this.saveJSON(distPathStr + ".json", JSON.stringify(d), function () { });
            }
            var s = this.parseToDTS(d);
            //add referrence paths to d.ts
            if (this.option.lib) {
                var refs = this.option.lib
                    .map(function (v, i, a) {
                    return "/// <reference path=\"" + v + "\" />";
                })
                    .join("\n");
                s = refs + "\n" + s;
            }
            //add header
            s =
                "// Type definitions for " + this.userDefinedModuleName + "\n// Project: [LIBRARY_URL_HERE] \n// Definitions by: [YOUR_NAME_HERE] <[YOUR_URL_HERE]> \n// Definitions: https://github.com/borisyankov/DefinitelyTyped\n"
                    + s;
            if (this.option.isOutExport) {
                var n = this.option.exportModuleName ? this.option.exportModuleName : this.userDefinedModuleName;
                var reg = /^['"]([^']+)['"]$/;
                if (reg.test(n)) {
                    n = RegExp.$1;
                }
                s +=
                    "\ndeclare module '" + n + "' {\n";
                if (this.option.exportStyle === dtsmake.Option.ExportStyle.ES6) {
                    s +=
                        "\n\texport default " + this.userDefinedModuleName + ";    //es6 style module export \n";
                }
                else {
                    s +=
                        "\n\texport = " + this.userDefinedModuleName + ";    //legacy ts module export\n";
                }
                s += "}" + "\n";
            }
            return s;
        };
        DTSMake.prototype.preModifiedJson = function (data) {
            var modJson = clone(data);
            //searching defined objects
            var reg = /[.]/;
            for (var i in modJson[dtsmake.TernDef.DEFINE]) {
                var value = modJson[dtsmake.TernDef.DEFINE][i];
                if (typeof i === "string" && reg.test(i)) {
                    //matched
                    var p = i.split(".");
                    if (p.length <= 1)
                        continue; //not defined path
                    //naming
                    var s = "";
                    if (value[0] && value[0].class && value[0].type === TSObjType.CLASS) {
                        //already defined class
                        var np = value[0].class.split(".");
                        s = np[np.length - 1];
                    }
                    else {
                        s = this.resolvePathToDTSName(p);
                    }
                    //replace
                    this.searchAndReplaceDTS(modJson, p, s);
                    //save
                    if (typeof value === "string") {
                        //only !type node
                        var typeStr = value.toString();
                        modJson[dtsmake.TernDef.DEFINE][i] = {};
                        modJson[dtsmake.TernDef.DEFINE][i][dtsmake.TernDef.TYPE] = typeStr;
                        //console.log("-----------------");
                        //console.log(JSON.stringify(value));
                    }
                    else if (value instanceof Array) {
                        if (value[0].class) {
                            //same class instance
                        }
                    }
                    modJson[dtsmake.TernDef.DEFINE][i][DTS_INTERFACE_STR] = s;
                    //console.log("-----------------");
                    //console.log(JSON.stringify(value));
                    //namespace
                    var ns = this.resolveNamespace(p);
                    if (ns !== "") {
                        modJson[dtsmake.TernDef.DEFINE][i][DTS_NAMESPACE_STR] = ns;
                    }
                }
            }
            //same with js global object name
            var GENDOC = "\n[dtsmake] this is generated by dtsmake.\n";
            for (var j in modJson) {
                if (typeof j === "string" && this.isJSGlobalObject(j)) {
                    //console.log("JS Global same :"+ j)
                    //console.log("option:"+this.option.globalObject)
                    switch (this.option.globalObject) {
                        case dtsmake.Option.GlobalObject.REMOVE:
                            break;
                        case dtsmake.Option.GlobalObject.WRAP:
                            var n = (this.userDefinedModuleName ? this.userDefinedModuleName : "Lib"); // + "." + j;
                            if (!modJson[n])
                                modJson[n] = {};
                            var c = j;
                            if (modJson[n][c]) {
                                c = c + (Math.random() * 1000 | 0);
                            }
                            modJson[n][c] = clone(modJson[j]);
                            modJson[n][c][DTS_INTERFACE_STR] = c;
                            //modJson[n][c][TernDef.TYPE] = TSObjType.FUNCTION;
                            break;
                        case dtsmake.Option.GlobalObject.RENAME:
                            var n2 = (this.userDefinedModuleName ? this.userDefinedModuleName : "Lib") + "$" + j;
                            if (modJson[n2]) {
                                n2 = n2 + (Math.random() * 1000 | 0);
                            }
                            modJson[n2] = {};
                            modJson[n2] = clone(modJson[j]);
                            break;
                        case dtsmake.Option.GlobalObject.RENAME_EXTEND:
                            /*
                            let n3 = (this.userDefinedModuleName ? this.userDefinedModuleName : "Lib") + "$" + j;
                            if(modJson[n3]){
                                n3 = n3 + (Math.random()*1000|0);
                            }
                            
                            modJson[n3] = {};
                            modJson[n3] = clone(modJson[j]);
                            if(!modJson[n3][TernDef.PROTO])modJson[n3][TernDef.PROTO] = {type:TSObjType.CLASS,class:`${j}.prototype`};
                            console.log("modJson[n3]:"+modJson[n3]);
                            */
                            break;
                    }
                    //remove base
                    modJson[j] = null;
                    delete modJson[j];
                }
            }
            this.modJson = modJson;
            return modJson;
        };
        DTSMake.prototype.replaceExportNamespace = function (data) {
            var modJson = clone(data);
            //nodejs node
            if (modJson[dtsmake.TernDef.DEFINE][dtsmake.TernDef.NODE]) {
                var nodejsNode = modJson[dtsmake.TernDef.DEFINE][dtsmake.TernDef.NODE];
                for (var i in nodejsNode) {
                    //replace
                    nodejsNode[this.userDefinedModuleName] = clone(nodejsNode[i]);
                    //remove
                    delete nodejsNode[i];
                }
            }
            //other nodes
            for (var i in modJson[dtsmake.TernDef.DEFINE]) {
                var cNode = modJson[dtsmake.TernDef.DEFINE][i];
                if (cNode[DTS_NAMESPACE_STR] && !/\./.test(cNode[DTS_NAMESPACE_STR])) {
                    //replace namespace
                    cNode[DTS_NAMESPACE_STR] = this.userDefinedModuleName;
                }
            }
            if ((modJson[this.userDefinedModuleName] &&
                modJson[this.userDefinedModuleName] instanceof Object &&
                Object.keys(modJson[this.userDefinedModuleName]).length === 0) ||
                (modJson[this.userDefinedModuleName] &&
                    modJson[this.userDefinedModuleName] instanceof Object &&
                    Object.keys(modJson[this.userDefinedModuleName]).length === 1 &&
                    modJson[this.userDefinedModuleName][dtsmake.TernDef.SPAN])) {
                //remove
                delete modJson[this.userDefinedModuleName];
            }
            return modJson;
        };
        DTSMake.prototype.resolvePathToDTSName = function (paths) {
            var s = "";
            var reg2 = /^!.+/;
            var reg3 = /<.+>/;
            for (var j = paths.length - 1; j > 0; j--) {
                //console.log("P[J]:"+p[j]);
                if (reg2.test(paths[j])) {
                    //tern def name
                    var tmp = paths[j]
                        .replace("!", "")
                        .replace(/^[a-z]/, function (val) {
                        return val.toUpperCase();
                    });
                    //console.log("DEFNAME:" + tmp);
                    s = tmp + s;
                    //console.log("DEFNAME2:" + s);
                }
                else if (reg3.test(paths[j])) {
                    //array type 
                    var tmp = paths[j]
                        .replace(/^</, "")
                        .replace(/>$/, "")
                        .replace(/^[a-z]/, function (val) { return val.toUpperCase(); });
                    s = tmp + s;
                }
                else if (/\//.test(paths[j])) {
                    if (paths[j] === this.nodeModuleName) {
                        s = this.userDefinedModuleName
                            .replace(/^[a-z]/, function (val) { return val.toUpperCase(); })
                            + s;
                    }
                    //console.log("DTSNAME:"+s);
                    break;
                }
                else {
                    //create defined name
                    //console.log("BEFORENAME:" + s);
                    var s2 = paths[j].replace(/^[a-z]/, function (val) {
                        return val.toUpperCase();
                    });
                    s = s2 + s;
                    //console.log("NEW NAME: "+s);
                    break; //end
                }
            }
            return s;
        };
        DTSMake.prototype.resolveNamespace = function (p) {
            var nsp = [];
            var len = p.length;
            var reg2 = /^!.+/;
            var reg3 = /<.+>/;
            var isOutRepNS = this.option.isOutExport;
            for (var i = len - 1; i >= 0; i--) {
                if (reg2.test(p[i]) || reg3.test(p[i])) {
                    if (i === len - 1)
                        nsp = []; //reset
                    else if (i >= 1) {
                        var tmpPath = ["!test", p[i - 1], p[i]];
                        //console.log("tmpPath:"+tmpPath.join("."))
                        nsp.push(this.resolvePathToDTSName(tmpPath));
                    }
                    i--;
                    continue;
                }
                if ((isOutRepNS && p[i] === this.nodeModuleName) ||
                    (isOutRepNS && /[`\/]/.test(p[i]))) {
                    //replace nodejs namespace
                    if (this.userDefinedModuleName) {
                        nsp.push(this.userDefinedModuleName);
                    }
                    //console.log(`nodeModule: ${this.nodeModuleName}`);
                    //console.log(`userDifined: ${this.userDefinedModuleName}`);
                }
                else {
                    nsp.push(p[i]);
                }
            }
            return nsp.reverse().join(".");
        };
        /**
         * @param path searching ref path
         * @param name a new name to replace
         * @param isCheckDefine when in true, search & replace in "!define" object
         */
        DTSMake.prototype.searchAndReplaceDTS = function (data, path, name, isCheckDefine) {
            var _this = this;
            if (isCheckDefine === void 0) { isCheckDefine = true; }
            var len = path.length;
            //type check
            var t = path[len - 1];
            var rt = this.checkReplaceType(t);
            //search
            var ref = this.searchRef(data, path, isCheckDefine);
            if (!ref || !ref[0])
                return; //no path
            /*if(name=="GulpHeader1"){
                //console.trace();
                console.log("GulpHeader1:", path.join("."));
                //console.log("ref:"+JSON.stringify(this.searchRef(data, path, isCheckDefine)));
                console.log("rt:"+rt);
                //console.log("resolveNamespace(path):", this.resolveNamespace(path))
            };*/
            //replace
            switch (rt) {
                case ReplaceType.RETURN:
                    if (!ref || !ref[0]) {
                        if (this.option.isDebug)
                            console.warn("t:" + t + "," + JSON.stringify(ref));
                        return;
                    }
                    var ret = ref[0]["ret"];
                    var retLen = ret.length;
                    if (this.option.isDebug)
                        console.warn("Ret:", name, path, ret);
                    if (retLen === 1) {
                        var ns = this.resolveNamespace(path);
                        if (this.option.isDebug)
                            console.warn("ns", ns);
                        ret[0].class = (ns != "") ? ns + "." + name : name;
                        ret[0].type = TSObjType.CLASS;
                    }
                    else {
                        var ns = this.resolveNamespace(path);
                        if (this.option.isDebug)
                            console.warn("ns", ns);
                        //TODO:real replace
                        var o = {};
                        o.class = (ns != "") ? ns + "." + name : name; //name;
                        o.type = TSObjType.CLASS;
                        ret.push(o);
                    }
                    //console.log("ret_name:"+name);
                    //console.log(`replace[${t}]:${JSON.stringify(ref[0]["ret"])}`);
                    break;
                case ReplaceType.PARAM:
                    if (!ref || !ref[0]) {
                        //console.log("t:"+t+","+JSON.stringify(ref));
                        return;
                    }
                    var n = Number(t.replace(/^!/, ""));
                    //console.log(`ref:${JSON.stringify(ref)}`);
                    //console.log(`ref[0]:${JSON.stringify(ref[0])}`);
                    //console.log(`ref[0]["params"]:${JSON.stringify(ref[0]["params"])}`);
                    var param = ref[0]["params"][n];
                    if (param instanceof Array) {
                        var o = {};
                        o.class = name;
                        o.type = TSObjType.CLASS;
                        //if same type has, then replace
                        var pStr = path.slice(0, path.length - 2).join(".") + "." + name;
                        var hasSameClass = param
                            .some(function (v, i, a) {
                            return v.class && _this.resolvePathToDTSName(v.class.split(".")) === name;
                        });
                        //console.log("hasSameClass:", hasSameClass, name);
                        /*let test = (<Array<TSObj>>param)
                            .some((v,i,a)=>{
                                return v.class && this.resolvePathToDTSName(v.class.split(".")) === name
                            });*/
                        //console.log("test",test);
                        if (hasSameClass) {
                            param
                                .filter(function (v, i, a) {
                                return v.class && _this.resolvePathToDTSName(v.class.split(".")) === name;
                            })
                                .map(function (v, i, a) {
                                v.type = TSObjType.CLASS;
                                v.class = name;
                            });
                        }
                        else {
                            param.push(o);
                        }
                    }
                    else {
                        var ns = this.resolveNamespace(path);
                        //console.log("ns!:"+ns)
                        param.class = (ns != "") ? ns + "." + name : name;
                        param.type = TSObjType.CLASS;
                    }
                    //ref[0].class = name;
                    //console.log(`replace[${t}]:${JSON.stringify(ref[0]["params"])}`);
                    break;
                case ReplaceType.CLASS:
                    //console.log("REP CLASS "+name);
                    ref[0]["class"] = "";
                    ref[0].class = name;
                    //console.log(`replace[${t}]:${JSON.stringify(ref[0])}`);
                    break;
                case ReplaceType.ARRAY:
                    //replacing array type
                    var at = ref[0]["arrayType"];
                    var nspace = path.slice(0, path.length - 2).join(".") + "." + name;
                    var nt = {
                        type: TSObjType.CLASS,
                        class: nspace
                    };
                    //ref[0]["arrayType"] = nt;
                    at[at.length - 1] = nt;
                    //console.log("REP_ARRAY:", name, JSON.stringify(at));
                    break;
                case ReplaceType.OTHER:
                    //ref[0].class = `/* ${name} */ any`;
                    break;
            }
        };
        DTSMake.prototype.searchRef = function (data, path, isCheckDefine) {
            var len = path.length;
            if (data[path[0]])
                isCheckDefine = false;
            var ref = isCheckDefine ? data[dtsmake.TernDef.DEFINE] : data;
            var OBJECT_TO_STRING = "$toString";
            var OBJECT_VALUE_OF = "$valueOf";
            for (var i = 0; i < len - 1; i++) {
                var s = path[i];
                //Object prototype prop special replace
                if (s === "toString")
                    s = OBJECT_TO_STRING;
                if (s === "valueOf")
                    s = OBJECT_VALUE_OF;
                if (s === "prototype" &&
                    !ref[s] &&
                    ///^[A-Z].*/.test(path[i-1])
                    this.checkReplaceType(path[i - 1]) === ReplaceType.CLASS) {
                    //may be class member
                    continue;
                }
                else if (ref[s] === undefined) {
                    //no path ref
                    //check from top
                    if (i > 0) {
                        var pname = path.slice(0, i).join(".") + "." + s;
                        var iData = data[dtsmake.TernDef.DEFINE];
                        if (iData[pname]) {
                            ref = iData[pname];
                            continue;
                        }
                        if (this.option.isDebug) {
                            console.warn("pname", pname);
                            console.warn("iData[pname]", JSON.stringify(iData[pname]));
                        }
                    }
                    //TODO: ref path !n or !ret to searching
                    if (this.option.isDebug) {
                        console.warn("current ref path:" + s);
                        console.warn("no path ref:" + path.join("."));
                        console.warn("data", JSON.stringify(ref));
                    }
                    return undefined; //do nothing
                }
                else {
                    ref = ref[s];
                }
            }
            //has !type node
            if (ref[dtsmake.TernDef.TYPE]) {
                ref = ref[dtsmake.TernDef.TYPE];
            }
            return ref;
        };
        DTSMake.prototype.checkReplaceType = function (s) {
            var rt;
            if (s === "!ret") {
                //return
                rt = ReplaceType.RETURN;
            }
            else if (/^![0-9]+/.test(s)) {
                //param
                rt = ReplaceType.PARAM;
            }
            else if (/^[A-Z].*/.test(s)) {
                //class or object, may be class
                rt = ReplaceType.CLASS;
            }
            else if (/^<.+>$/.test(s)) {
                //array type
                rt = ReplaceType.ARRAY;
                //TODO:Array type replace
            }
            else {
                //other
                rt = ReplaceType.OTHER;
            }
            return rt;
        };
        DTSMake.prototype.ternDefClassToDTSClass = function (ternClassStr) {
            var s = "";
            //console.log("-----------CLASS-------------");
            //console.log(ternClassStr);
            var regInstance = /^\+.*/;
            var regDefined = /^!.+/;
            if (regInstance.test(ternClassStr)) {
                //some class instance
                var p = ternClassStr.split(".");
                s = p[p.length - 1];
            }
            else if (regDefined.test(ternClassStr)) {
                //path to class
                var p = ternClassStr.split(".");
                s = this.resolvePathToDTSName(p);
                //console.log("-----------CLASS-------------");
                //console.log(ternClassStr);
                //this.modJson;
            }
            return s;
        };
        /**
         * ternjs type definition to TSObj
         */
        DTSMake.prototype.parseJsonNodeDTS = function (data) {
            var o = JSON.parse("{}");
            for (var i in data) {
                var value = void 0;
                value = data[i];
                switch (i) {
                    //converts
                    case dtsmake.TernDef.DEFINE:
                        o[i] = {};
                        if (typeof value === "string")
                            continue;
                        else {
                            for (var j in value) {
                                o[i] = this.parseJsonNodeDTS(value);
                            }
                        }
                        break;
                    case dtsmake.TernDef.NODE:
                        /*if(typeof value === "string"){
                            this.option.isNodeJsModule = true;
                            this.nodeModuleName = value;
                        }else */
                        if (typeof i === "string") {
                            if (Object.keys(value).length === 1) {
                                this.nodeModuleName = Object.keys(value)[0];
                            }
                        }
                        o[i] = this.parseJsonNodeDTS(value);
                        break;
                    //no converts
                    case dtsmake.TernDef.NAME:
                        this.userDefinedModuleName = value;
                    case dtsmake.TernDef.DOC:
                    case dtsmake.TernDef.URL:
                        o[i] = value;
                        break;
                    default:
                        if (typeof value === "string") {
                            //node end
                            //Object has same name default
                            switch (i) {
                                case "toString":
                                case "valueOf":
                                    var newPropName = "$" + i;
                                    o[newPropName] = {};
                                    o[newPropName] = this.parseTernDef(value);
                                    break;
                                default:
                                    o[i] = this.parseTernDef(value);
                            }
                        }
                        else if (value[dtsmake.TernDef.TYPE] &&
                            value["prototype"]) {
                            //has !type && .prototype
                            o[i] = {};
                            //constructor
                            o[i][dtsmake.DTSDef.NEW] = {};
                            o[i][dtsmake.DTSDef.NEW] = this.parseTernDef(value[dtsmake.TernDef.TYPE], i, true);
                            //prototype
                            for (var j in value["prototype"]) {
                                if (typeof value["prototype"][j] === "string")
                                    o[i][j] = this.parseTernDef(value["prototype"][j]);
                                else
                                    o[i][j] = this.parseJsonNodeDTS(value["prototype"][j]);
                            }
                            //member without prototype/!type
                            for (var j in value) {
                                if (j === dtsmake.TernDef.TYPE)
                                    continue;
                                if (j === "prototype")
                                    continue;
                                if (typeof value[j] === "string") {
                                    if (j === dtsmake.TernDef.DOC ||
                                        j === dtsmake.TernDef.URL) {
                                        o[i][j] = value[j];
                                    }
                                    else {
                                        o[i][j] = this.parseTernDef(value[j]);
                                    }
                                }
                                else {
                                    o[i][j] = this.parseJsonNodeDTS(value[j]);
                                }
                            }
                        }
                        else {
                            o[i] = this.parseJsonNodeDTS(value);
                        }
                        break;
                }
            }
            return o;
        };
        DTSMake.prototype.parseToDTS = function (data, parent) {
            var s = "";
            for (var i in data) {
                var value = void 0;
                value = data[i];
                switch (i) {
                    case dtsmake.TernDef.NAME:
                        //s += `/* LIB: ${value} */\n`;
                        break;
                    case dtsmake.TernDef.DEFINE:
                        //already defined class instance
                        if (value instanceof Array)
                            continue;
                        //nothing
                        if (typeof value === "string")
                            continue;
                        this.isInDefine = true;
                        for (var j in value) {
                            //nodejs module
                            if (j === dtsmake.TernDef.NODE) {
                                this.isNodeJsModule = true;
                                var dont = [];
                                var wrap = [];
                                for (var k in value[dtsmake.TernDef.NODE]) {
                                    var v = value[dtsmake.TernDef.NODE][k];
                                    if (v[dtsmake.TernDef.TYPE]) {
                                        dont[k] = {};
                                        dont[k] = clone(v);
                                    }
                                    else {
                                        wrap[k] = {};
                                        wrap[k] = clone(v);
                                    }
                                }
                                //dont wrap
                                s += this.parseToDTS(dont);
                                //wrap
                                s += this.wrapNamespace(wrap, dtsmake.TernDef.NODE);
                                this.isNodeJsModule = false;
                            }
                            else {
                                var ns = "";
                                var defName = "";
                                if (value[j][DTS_INTERFACE_STR]) {
                                    defName = value[j][DTS_INTERFACE_STR].toString();
                                    delete value[j][DTS_INTERFACE_STR];
                                }
                                else {
                                    defName = j;
                                }
                                //has namespace
                                if (value[j][DTS_NAMESPACE_STR]) {
                                    ns = value[j][DTS_NAMESPACE_STR];
                                    delete value[j][DTS_NAMESPACE_STR];
                                }
                                //already defined no output
                                if (value[j] instanceof Array &&
                                    value[j].length === 1 &&
                                    value[j][0].type === TSObjType.CLASS) {
                                    continue;
                                }
                                //outputs
                                if (ns != "") {
                                    //namespace open
                                    s += this.indent();
                                    s += this.addDeclare(true);
                                    s += "namespace " + ns + "{\n";
                                    this.depth++;
                                }
                                //type alias
                                if (value[j] instanceof Array) {
                                    s += this.indent();
                                    s += "// " + j + "\n";
                                    s += this.indent();
                                    s += "type " + defName + " = ";
                                    s += this.tsObjsToUnionDTS(value[j], value[j].some(function (v, i, a) { return v.type === TSObjType.FUNCTION; }));
                                    s += ";\n";
                                }
                                else if (typeof value[j] === "string") {
                                    s += this.indent();
                                    s += this.outJSDoc(value[j][dtsmake.TernDef.DOC] ? value[j][dtsmake.TernDef.DOC] : undefined, value[j][dtsmake.TernDef.URL] ? value[j][dtsmake.TernDef.URL] : undefined);
                                    s += "var " + defName + ": " + value[j] + "\n";
                                }
                                else {
                                    s += this.interfaceDTS(defName, value[j], j);
                                }
                                if (ns != "") {
                                    //namespace close
                                    this.depth--;
                                    s += this.indent();
                                    s += "}\n";
                                }
                            }
                        }
                        this.isInDefine = false;
                        //}
                        break;
                    case dtsmake.TernDef.DOC:
                        //output only jsdoc
                        break;
                    case dtsmake.TernDef.SPAN:
                        break;
                    case dtsmake.TernDef.TYPE:
                        if (this.isInClassOrInterface) {
                            s += this.indent();
                            s += this.convertTSObjToString("", value, value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
                        }
                        break;
                    case dtsmake.TernDef.PROTO:
                        break;
                    case "<i>":
                        //TODO:research ternjs def's `<i>` mean & what to do
                        // Maybe ternjs cannot get prop name.
                        // so, currently, dtsmake don't output.
                        break;
                    default:
                        //grammer error name replace
                        if (/[\*\-]/.test(i)) {
                            i = "\"" + i + "\"";
                            /*
                            if(parent){
                                parent[i] = {};
                                parent[i] = clone(value);
                            }
                            break;
                            */
                        }
                        //node end
                        if (value instanceof Array) {
                            s += this.indent();
                            s += this.convertTSObjToString(i, value, value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
                        }
                        else if (typeof value === "string") {
                            s += this.outJSDoc(value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
                            s += this.indent();
                            s += this.addDeclare();
                            s += i + " : " + value;
                        }
                        else if (value && (value[dtsmake.DTSDef.NEW] || value[dtsmake.TernDef.PROTO] || value[DTS_INTERFACE_STR]) && !this.isInClassOrInterface) {
                            if (this.option.globalObject === dtsmake.Option.GlobalObject.WRAP &&
                                value[DTS_INTERFACE_STR]) {
                                delete value[DTS_INTERFACE_STR];
                            }
                            s += this.interfaceDTS(i, value);
                        }
                        else if (value instanceof Object && Object.keys(value).length === 0) {
                            s += this.indent();
                            s += this.convertTSObjToString(i, [{}], value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
                        }
                        else if (value &&
                            value[dtsmake.TernDef.TYPE]) {
                            //s += this.outJSDoc();
                            s += this.indent();
                            s += this.convertTSObjToString(i, value[dtsmake.TernDef.TYPE], value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
                            //children
                            if (Object.keys(value).length > 1) {
                                var v = clone(value);
                                delete v[dtsmake.TernDef.TYPE];
                                delete v[dtsmake.TernDef.DOC];
                                delete v[dtsmake.TernDef.URL];
                                if (this.option.isDebug) {
                                    console.log("I:" + i, JSON.stringify(v), Object.keys(v).length);
                                }
                                if (Object.keys(v).length > 0 && !this.isInClassOrInterface) {
                                    //s += this.outNamespaceDTS(v, i, parent);
                                    s += this.outNamespaceOrInterface(v, i);
                                }
                                //TODO: isInClassOrInterface == true, export namespace
                            }
                        }
                        else if (this.isNamespace(value)) {
                            s += this.outNamespaceOrInterface(value, i);
                        }
                        else {
                            s += this.outJSDoc(value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
                            s += this.indent();
                            //object literal type
                            if (!this.isInObjectLiteral && !this.isInClassOrInterface) {
                                s += this.addDeclare();
                                s += "var ";
                            }
                            s += i + " : {\n";
                            this.isInObjectLiteral = true;
                            this.depth++;
                            //s += this.indent();
                            s += this.parseToDTS(value, parent);
                            this.depth--;
                            this.isInObjectLiteral = false;
                            s += this.indent();
                            s += "}\n";
                        }
                        break;
                }
            }
            return s;
        };
        DTSMake.prototype.addDeclare = function (flag) {
            var DECLARE_STR = "declare ";
            if (flag && flag === true)
                return DECLARE_STR;
            else if (this.depth === 0)
                return DECLARE_STR;
            else
                return "";
        };
        DTSMake.prototype.outNamespaceOrInterface = function (value, name, path) {
            var s = "";
            var outI = {};
            var outN = {};
            for (var i in value) {
                if (!value[i])
                    continue;
                var v = value[i];
                if (v[0] &&
                    v[0].type === TSObjType.FUNCTION &&
                    /[\*\-]/.test(i)) {
                    //export in interface
                    outI[i] = clone(v);
                }
                else {
                    //export in interface
                    //outI[i] = clone(v);
                    outN[i] = clone(v);
                }
            }
            if (Object.keys(outN).length > 0)
                s += this.outNamespaceDTS(outN, name);
            if (Object.keys(outI).length > 0)
                s += this.interfaceDTS(name, outI);
            return s;
        };
        DTSMake.prototype.outNamespaceDTS = function (value, name, parent) {
            var s = "";
            s += this.outJSDoc(value[dtsmake.TernDef.DOC], value[dtsmake.TernDef.URL]);
            s += this.indent();
            s += this.addDeclare();
            s += "namespace " + name + "{\n";
            this.depth++;
            s += this.parseToDTS(value, parent);
            this.depth--;
            s += this.indent();
            s += "}\n";
            return s;
        };
        /**
         * @param defName interface name
         */
        DTSMake.prototype.interfaceDTS = function (defName, value, path) {
            var s = "";
            //interface name
            if (path) {
                s += this.indent();
                s += "// " + path + "\n"; //TODO:output option ternjs internal ref path
            }
            s += this.outJSDoc(value[dtsmake.TernDef.DOC] ? value[dtsmake.TernDef.DOC] : null, value[dtsmake.TernDef.URL] ? value[dtsmake.TernDef.URL] : null);
            s += this.indent();
            s += this.addDeclare();
            s += "interface " + defName;
            //extending other class/interface
            if (value[dtsmake.TernDef.PROTO]) {
                var proto = value[dtsmake.TernDef.PROTO];
                if (proto instanceof Array &&
                    proto.length > 1) {
                    var str = "Object extends 2 or more other objects, but TypeScript only extends SINGLE Class/Interface.";
                    console.warn(str);
                    s += "/* " + str + " */";
                }
                else {
                    var t = proto[0];
                    //resolve path to object prototype
                    if (!t.class) {
                        if (this.option.isDebug)
                            console.log("t:" + JSON.stringify(t));
                        //return;
                    }
                    else {
                        var p = t.class.split(".");
                        if (p[p.length - 1] === "prototype") {
                            //output
                            var ext = p.slice(0, p.length - 1).join(".");
                            s += " extends " + ext;
                        }
                        //delete temp property
                        value[dtsmake.TernDef.PROTO] = undefined;
                        delete value[dtsmake.TernDef.PROTO];
                    }
                }
            }
            //interface body
            this.isInClassOrInterface = true;
            this.isInObjectLiteral = true;
            this.isNeedDeclare = false;
            s += " {\n";
            this.depth++;
            s += this.parseToDTS(value);
            this.depth--;
            s += this.indent();
            s += "}\n";
            this.isInObjectLiteral = false;
            this.isInClassOrInterface = false;
            this.isNeedDeclare = true;
            //interface var to new()
            if (value[dtsmake.DTSDef.NEW] && this.option.isExportInterfaceSameNameVar) {
                s += this.indent();
                s += this.addDeclare();
                s += "var " + defName + ": " + defName + ";\n";
            }
            return s;
        };
        DTSMake.prototype.isNamespace = function (value) {
            if (!value) {
                return false;
            }
            else if (value instanceof Array)
                return false;
            else if (value[dtsmake.TernDef.TYPE])
                return false;
            else if (!(value instanceof Object))
                return false;
            else if (Object.keys(value).length === 0)
                return false;
            else if (this.isInClassOrInterface) {
                return false;
            }
            else {
                for (var i in value) {
                    if (!value[i])
                        continue;
                    if (value[i] instanceof Object &&
                        Object.keys(value[i]).length > 1) {
                        return true;
                    }
                    else if (value[i][0] &&
                        value[i][0].type &&
                        (value[i][0].type === TSObjType.FUNCTION ||
                            value[i][0].type === TSObjType.BOOLEAN ||
                            value[i][0].type === TSObjType.ARRAY)) {
                        return true;
                    }
                }
                return false;
            }
        };
        /**
         *
         */
        DTSMake.prototype.outJSDoc = function (comment, url, params, ret) {
            var s = "";
            return s;
            //jsdoc open
            s += this.indent();
            s += "\n";
            s += this.indent();
            s += "/**\n";
            //base comment from js files
            s += this.indent();
            if (comment) {
                //TODO:support multi platform BR
                var aComment = comment.split("\n");
                var len = aComment.length;
                for (var i = 0; i < len; i++) {
                    if (i !== 0)
                        s += this.indent();
                    s += " * " + aComment[i] + "\n";
                }
            }
            else {
                s += " * \n";
            }
            //params
            if (params) {
                for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                    var i = params_1[_i];
                    s += this.indent();
                    s += " * @param " + i + " \n";
                }
            }
            //returns
            if (ret) {
                s += this.indent();
                s += " * @return " + ret + "\n";
            }
            //url
            if (url) {
                s += this.indent();
                s += " * @url " + url + "\n";
            }
            //jsdoc close
            s += this.indent();
            s += " */\n";
            return s;
        };
        DTSMake.prototype.outFuncJsDocs = function (t, docData, urlData) {
            var s = "";
            return s;
            var ps = (t.params) ?
                t.params
                    .map(function (v, i, a) {
                    if (v instanceof Array) {
                        return v[0].name;
                    }
                    else {
                        return v.name;
                    }
                }) :
                null;
            var rs = (!t.ret ||
                t.ret
                    .every(function (v, i, a) { return v.type === TSObjType.VOID; })) ?
                null :
                //t.ret.map((v,i,a)=> v.class ? v.class : "").join(", ");
                //TODO:return info
                " ";
            s += this.outJSDoc(docData, urlData, ps, rs);
            return s;
        };
        DTSMake.prototype.convertTSObjToString = function (symbolName, tsObjects, docData, //TODO:support doc data
            urlData, //TODO:support url data
            spanData //TODO:support spandata
        ) {
            var s = "";
            var keyword = "";
            var isFunc = false;
            if (tsObjects[0].type === TSObjType.FUNCTION) {
                isFunc = true;
            }
            //Object property special replace revert
            if (/^\$(toString|valueOf)$/.test(symbolName)) {
                //console.log(symbolName+" should revert.");
                symbolName = symbolName.replace(/^\$/, "");
            }
            //may be class
            var isMaybeClass = false;
            if (/^[A-Z]/.test(symbolName) &&
                tsObjects[0].type === TSObjType.FUNCTION) {
                isMaybeClass = true;
            }
            //keyword
            if (this.isInClassOrInterface) {
            }
            else if (this.isInObjectLiteral) {
            }
            else {
                if (isFunc && !isMaybeClass) {
                    keyword = "function ";
                }
                else if (isFunc && isMaybeClass) {
                    //TODO:option class or interface (default)
                    keyword = "class ";
                }
                else {
                    keyword = "var ";
                }
            }
            //function not class/interface
            if (isFunc && !isMaybeClass) {
                var ol = tsObjects.length;
                //TODO:overloads support
                //out
                ol = tsObjects.length;
                for (var i = 0; i < ol; i++) {
                    var t = tsObjects[i];
                    //console.log("T:"+JSON.stringify(t));
                    //jsdoc
                    s += this.outFuncJsDocs(t, docData, urlData);
                    s += this.indent();
                    //output function d.ts
                    s += this.addDeclare();
                    s += keyword + symbolName + "(" + this.paramsToDTS(t.params) + ")";
                    //return type					
                    if (t.ret &&
                        symbolName === dtsmake.DTSDef.NEW &&
                        !this.option.isAnnotateTypeInstance &&
                        t.ret.every(function (v) { return v.type === TSObjType.VOID; })) {
                        //constructor maynot return self instance
                        //no output type annotation
                    }
                    else if (t.ret) {
                        s += ": " + this.tsObjsToUnionDTS(t.ret, (t.ret.length > 1) ? true : false, t, false);
                    }
                    if (i !== ol - 1) {
                        //overload function
                        s += ";";
                    }
                }
                //s += keyword + symbolName + "():" + JSON.stringify(tsObjects);
            }
            else if (isFunc && isMaybeClass) {
                var nt = (_a = {},
                    //type:TSObjType.FUNCTION,
                    _a[dtsmake.DTSDef.NEW] = [],
                    _a[dtsmake.TernDef.DOC] = docData ? docData : null //,
                ,
                    _a);
                if (urlData)
                    nt[dtsmake.TernDef.URL] = urlData;
                for (var i in tsObjects) {
                    if (i === dtsmake.TSObj.Def.TYPE)
                        continue;
                    var tmp = tsObjects[i];
                    //console.log("TMP:", JSON.stringify(tmp));
                    tmp.ret
                        .filter(function (v, i, a) { return v.type === TSObjType.VOID; })
                        .map(function (v, i, a) {
                        //console.log("V1:",JSON.stringify(v))
                        v.type = TSObjType.CLASS;
                        v.class = symbolName;
                        //console.log("V2:",JSON.stringify(v))
                        return v;
                    });
                    nt[dtsmake.DTSDef.NEW].push(tmp);
                }
                s += this.interfaceDTS(symbolName, nt);
                /*
                if(false){
                    //class open
                    s += this.outJSDoc(docData,urlData);
                    s += this.indent();
                    s += keyword + symbolName + "{\n";
                    this.depth++;
                    
                    //constructor only
                    for(let i in tsObjects){
                        //constructor overloads
                        let t = tsObjects[i];
                        
                        //jsdoc
                        s += this.indent();
                        s += this.outFuncJsDocs(t, docData,urlData)
                        
                        
                        s += this.indent();
                        s += "constructor(" + this.paramsToDTS(t.params) +");\n";
                    }
                    
                    //class close
                    this.depth--;
                    s += this.indent();
                    s += "}";
                }
                */
            }
            else {
                s += this.outJSDoc(docData, urlData);
                s += this.indent();
                if (!this.isInDefine && !this.isInObjectLiteral && !this.isInClassOrInterface)
                    s += "export ";
                s += this.addDeclare();
                s += keyword + symbolName + " : " + this.tsObjsToUnionDTS(tsObjects);
            }
            //close ;
            if (isMaybeClass)
                s += "\n";
            else
                s += ";\n";
            //this.depth--;
            return s;
            var _a;
        };
        DTSMake.prototype.paramsToDTS = function (params) {
            //console.log("PARAMS:" + JSON.stringify(params));
            var _this = this;
            if (params == null)
                return "";
            else
                return params
                    .map(function (v, i, a) {
                    //console.log(`|-[${i}]:${JSON.stringify(v)}`);
                    if (v instanceof Array) {
                        return _this.tsObjsToUnionDTS(v, true);
                    }
                    else {
                        if (!v.name)
                            v.name = "param" + (i + 1);
                        return _this.tsObjToDTS(v);
                    }
                })
                    .join(", ");
        };
        /**
         * @param wrap wrap params with "()"
         */
        DTSMake.prototype.tsObjsToUnionDTS = function (t, wrap, parentTSObj, isOutName) {
            var _this = this;
            if (wrap === void 0) { wrap = false; }
            if (isOutName === void 0) { isOutName = true; }
            if (!t) {
                //not unions
                throw Error("union needs dts any tsObjs.");
            } //return "!!ERROR!!";
            //merge `any` only union
            var isOnlyAny = t
                .every(function (v, i, a) { return (v.type === TSObjType.ANY); });
            if (isOnlyAny) {
                return this.tsObjToDTS(t[0], wrap, parentTSObj, isOutName);
            }
            //replace `any` to `{}` or `Object` if this is not `any` only union
            //because typescript type inferrence can't show union types (eg. VS Code)
            var hasAny = t.some(function (v, i, a) { return (v.type === TSObjType.ANY); }) && (t.length > 1);
            if (hasAny) {
                t = t.map(function (v, i, a) {
                    if (v.type === TSObjType.ANY) {
                        v.type = TSObjType.CLASS;
                        v.class = "{}";
                    }
                    return v;
                });
            }
            return t
                .map(function (v, i, a) {
                var isOutParamName = isOutName;
                if (i !== 0)
                    isOutParamName = false;
                // v.name = null;	//don't output
                //if(!isOutName) v.name = null;
                return _this.tsObjToDTS(v, wrap, parentTSObj, isOutParamName);
            })
                .join(" | ");
        };
        DTSMake.prototype.tsObjToDTS = function (t, wrap, parentTSObj, isOutName) {
            if (wrap === void 0) { wrap = false; }
            if (isOutName === void 0) { isOutName = true; }
            if (!t)
                return " /* error */ any";
            var s = "";
            if (t.name && isOutName)
                s += t.name + " : ";
            wrap = wrap && (t.type === TSObjType.FUNCTION);
            if (wrap)
                s += "("; //wrap start
            switch (t.type) {
                case TSObjType.ANY:
                    s += "any";
                    break;
                case TSObjType.ARRAY:
                    s += "Array<" + this.tsObjsToUnionDTS(t.arrayType) + ">";
                    break;
                case TSObjType.BOOLEAN:
                    s += "boolean";
                    break;
                case TSObjType.CLASS:
                    //ref to user class
                    if (/^\+.+/.test(t.class)) {
                        //class instance
                        s += t.class.replace(/^\+/, "");
                        //TODO:check real path
                    }
                    else if (/\./.test(t.class)) {
                        var tp = t.class.split(".");
                        var last = tp[tp.length - 1];
                        if (/^[A-Z].+([0-9A-Z]|Ret)$/.test(last)) {
                            //replaced class name
                            s += t.class;
                        }
                        else {
                            //TODO: check path exist
                            //temporary output
                            s += "/* " + t.class + " */ any";
                        }
                    }
                    else {
                        s += t.class;
                    }
                    //this.ternDefClassToDTSClass(t.class);
                    break;
                case TSObjType.FUNCTION:
                    //console.log("TStoDTS:fn("+t.params+")"+(t.ret)?"=>"+t.ret:"");
                    s += "(" + this.paramsToDTS(t.params) + ")";
                    if (!t.ret) {
                        t.ret = [{ type: TSObjType.VOID }];
                    }
                    s += " => " + this.tsObjsToUnionDTS(t.ret, false, null, false);
                    break;
                case TSObjType.NUMBER:
                    s += "number";
                    break;
                case TSObjType.OBJECT:
                    if (t.class) {
                        switch (this.checkReplaceType(t.class)) {
                            case ReplaceType.PARAM:
                                //TODO:replace
                                var n = Number(t.class.replace(/^!/, ""));
                                if (!parentTSObj || !parentTSObj.params) {
                                    s += "/*" + t.class + "*/ any";
                                    break;
                                }
                                var rep = parentTSObj.params[n];
                                //
                                if (rep instanceof Array) {
                                    var isWrap = rep
                                        .some(function (v, i, a) { return v.type === TSObjType.FUNCTION; });
                                    s += this.tsObjsToUnionDTS(rep, isWrap, null, false);
                                }
                                else {
                                    s += this.tsObjToDTS(rep, false, null, false);
                                    if (rep &&
                                        rep.type &&
                                        rep.type === TSObjType.ANY) {
                                        s += " /* same type param \"" + rep.name + "\" */";
                                        //TODO:generate class/interface
                                    }
                                }
                                break;
                            case ReplaceType.RETURN:
                                //TODO:replace
                                s += "/* " + t.class + " */";
                                break;
                            case ReplaceType.ARRAY:
                                //TODO:replace
                                s += "/* Array<" + t.class + "> */";
                                break;
                            default:
                                if (this.isJSGlobalObject(t.class)) {
                                    s += t.class;
                                }
                                else {
                                    s += "/* " + t.class + " */ ";
                                    s += "any";
                                }
                                break;
                        }
                    }
                    else {
                        s += "any";
                    }
                    break;
                case TSObjType.STRING:
                    s += "string";
                    break;
                case TSObjType.UNIONS:
                    throw Error("unions? " + JSON.stringify(t));
                //break;
                case TSObjType.VOID:
                    if (this.option.isOutVoidAsAny)
                        s += "/* void */ any";
                    else
                        s += "void";
                    break;
                default:
                    s += "/*no type*/{}"; //no type
                    break;
            }
            if (wrap)
                s += ")"; //wrap end
            return s;
        };
        DTSMake.prototype.isJSGlobalObject = function (name) {
            var g = [
                "Object",
                "Function",
                "Boolean",
                "Symbol",
                "Error",
                "EvalError",
                "InternalError",
                "RangeError",
                "ReferenceError",
                "SyntaxError",
                "TypeError",
                "URIError",
                "Number",
                "Math",
                "Date",
                "String",
                "RegExp",
                "Array",
                "Int8Array",
                "Uint8Array",
                "Uint8ClampedArray",
                "Int16Array",
                "Uint16Array",
                "Int32Array",
                "Uint32Array",
                "Float32Array",
                "Float64Array",
                "Map",
                "Set",
                "WeakMap",
                "WeakSet",
                "ArrayBuffer",
                "DataView",
                "JSON",
                "Promise",
                "Generator",
                "GeneratorFunction",
                "Reflect",
                "Proxy"
            ];
            return g.some(function (v, i, a) { return v === name; });
        };
        /**
         *
         */
        DTSMake.prototype.wrapNamespace = function (value, nodeName) {
            var s = "";
            if (typeof value === "string") {
                throw Error(nodeName + " node value must not to be string.");
            }
            else {
                for (var j in value) {
                    //open namespace
                    s += "//nodejs module namespace\n";
                    s += this.addDeclare();
                    s += "namespace " + j + "{\n";
                    //TODO:use namespace keyword option
                    this.depth++;
                    //s += this.indent();
                    s += this.parseToDTS(value[j]);
                    this.depth--;
                    //close namespace
                    s += "}\n";
                }
            }
            return s;
        };
        DTSMake.prototype.indent = function () {
            var s = "";
            var INDENT_STR = "	"; //defalut tab string
            for (var i = 0 | 0; (i | 0) < (this.depth | 0); i++) {
                s += INDENT_STR;
            }
            return s;
        };
        DTSMake.prototype.convertTernJsToTs = function (ternDef) {
            var ts;
            return ts;
        };
        DTSMake.prototype.parseTernDef = function (ternDef, parentName, isConstructor) {
            if (isConstructor === void 0) { isConstructor = false; }
            if (!ternDef)
                throw Error("need ternjs def string.");
            //remove spaces
            ternDef = ternDef.replace(/[\s\t\n]+/g, "");
            //remove outer ()
            var reg = /^\((.+)\)$/;
            if (reg.test(ternDef)) {
                //console.log("reg:"+ternDef.match(reg)[1]);
                ternDef = ternDef.match(reg)[1];
                //console.log("rm ():"+ ternDef);
            }
            //
            var sa = this.splitUnions(ternDef);
            var ret = [];
            for (var _i = 0, sa_1 = sa; _i < sa_1.length; _i++) {
                var i = sa_1[_i];
                var ts = {};
                ts.type = this.checkType(i);
                if (parentName)
                    ts.name = parentName;
                if (ts.type === TSObjType.CLASS || ts.type === TSObjType.OBJECT) {
                    ts.class = i;
                    //console.log("++++++++++++++++++++++++");
                    //console.log(" ["+i+"]:" + ts.class);
                    //console.log("++++++++++++++++++++++++");
                }
                //console.log(`ts:${JSON.stringify(ts)}, ts.type:${ts.type}`);
                switch (ts.type) {
                    case TSObjType.UNIONS:
                        ret.push(this.parseTernDef(i));
                        continue;
                    //break;
                    case TSObjType.ARRAY:
                        //console.log("ARRAY:"+i);
                        //let test = i.replace(/^\[/,"").replace(/\]$/,"");
                        //console.log(`i.replace(/^\[/,"").replace(/\]$/,""):${test}`);
                        ts.arrayType =
                            this.parseTernDef(i.replace(/^\[/, "").replace(/\]$/, ""));
                        break;
                    case TSObjType.FUNCTION:
                        //console.log(`fn:${i}`);
                        ts.ret = this.parseFnReturn(i, parentName, isConstructor);
                        ts.params =
                            this.parseParams(i);
                        break;
                    case TSObjType.CLASS:
                    case TSObjType.OBJECT:
                        ts.class = i;
                        //console.log("---CLASS/Object----"+ i + "----------");
                        break;
                    case TSObjType.ANY:
                    case TSObjType.BOOLEAN:
                    case TSObjType.NUMBER:
                    default:
                        break;
                }
                ret.push(ts);
                //ret.push(this.parseTernDef(i));
            }
            //console.log(`ret:${JSON.stringify(ret)}`);
            return ret;
        };
        DTSMake.prototype.parseFnReturn = function (fnStr, parentName, isConstructor) {
            if (isConstructor === void 0) { isConstructor = false; }
            var sa = this.splitReturn(fnStr);
            if (isConstructor && this.option.isAnnotateTypeInstance && parentName && sa.length === 1) {
                //force annotate constructor return type instance
                return [{ type: TSObjType.CLASS, class: parentName }];
            }
            else if (sa.length === 1) {
                //void
                return [{ type: TSObjType.VOID }];
            }
            //console.log(`fn-ret:${sa[1]}`);
            //return null;
            /*
            let ret:any[] = [];
            for(let i of sa){
                ret.push(this.parseTernDef(i));
            }*/
            var ret = this.parseTernDef(sa[1]);
            if (isConstructor && this.option.isAnnotateTypeInstance && parentName) {
                ret
                    .filter(function (v, i, a) { return v.type === TSObjType.VOID; })
                    .map(function (v, i, a) {
                    return { type: TSObjType.CLASS, class: parentName };
                });
            }
            return ret;
        };
        DTSMake.prototype.parseParams = function (fnStr) {
            var fns = this.splitReturn(fnStr)[0];
            //console.log("paramFnStr: "+fns);
            var reg1 = /^fn\(/;
            var reg2 = /\)$/;
            //let reg3 = /.*->.*/;
            //still inner
            /*
            if(reg1.test(fnStr)&&reg2.test(fnStr)&&reg3.test(fnStr)){
                
            }*/
            var fna = reg1.test(fns) && reg2.test(fns) /*&& !reg3.test(fnStr) */ ?
                fns
                    .replace(/^fn\(/, "")
                    .replace(/\)$/, "") :
                fns;
            /*
            console.log(
                "\u001b[32m■[check!]:\u001b[0m"+
                reg1.test(fns)+
                "^"+
                reg2.test(fns)+
                //"^"+
                //!reg3.test(fnStr)+
                ",\n"+
                fna
            );*/
            if (!fna || fna.length === 1) {
                //console.log("no params. : "+fnStr)
                return null;
            }
            else {
                var paramStr = fna;
                //console.log("param_str[1]:"+ paramStr);
                //return;
                //*
                var sa = this.splitParams(paramStr);
                //console.log(`param_str[2]:${sa}, len:${sa.length}`)
                var ret = [];
                for (var _i = 0, sa_2 = sa; _i < sa_2.length; _i++) {
                    var i = sa_2[_i];
                    var n = i.search(/:/);
                    var name = (n === -1) ? null : i.substring(0, n);
                    var sType = i.substring(n + 1);
                    //console.log(`sType:${sType}`);
                    var checked = this.checkType(sType);
                    if (TSObjType.UNIONS === checked) {
                        //unions
                        var pa = this.parseTernDef(sType, name);
                        ret.push(pa);
                    }
                    else if (TSObjType.ARRAY === checked) {
                        var a = this.parseTernDef(sType, name);
                        if (a.length === 1) {
                            ret.push(a[0]);
                        }
                        else {
                            ret.push(a);
                        }
                    }
                    else {
                        var ts = {};
                        if (n !== -1)
                            ts.name = name;
                        ts.type = checked;
                        if (ts.type === TSObjType.OBJECT ||
                            ts.type === TSObjType.CLASS) {
                            ts.class = sType;
                        }
                        //if(n===-1)console.log(`ts:${ts.name},${ts.type}`);
                        ret.push(ts);
                    }
                }
                return ret;
            }
        };
        /**
         * ternjs type to typescript type enum
         * | (a|b) | UNIONS   |
         * | fn()  | FUNCTION |
         * |  ?    | ANY      |
         * | bool  | BOOLEAN  |
         * | number| NUMBER   |
         * | string| STRING   |
         * | [?]   | ARRAY    |
         * | +abc  | CLASS    |
         * | other above | OBJECT |
         * @return TSObjType return enums (number)
         */
        DTSMake.prototype.checkType = function (ternDef) {
            if (this.splitUnions(ternDef).length > 1) {
                return TSObjType.UNIONS;
            }
            else if (/^fn\*?\(/.test(ternDef)) {
                //function
                return TSObjType.FUNCTION;
            }
            else if (ternDef === "?") {
                return TSObjType.ANY;
            }
            else if (ternDef === "bool") {
                return TSObjType.BOOLEAN;
            }
            else if (ternDef === "number") {
                return TSObjType.NUMBER;
            }
            else if (ternDef === "string") {
                return TSObjType.STRING;
            }
            else if (/^\[.+\]$/.test(ternDef)) {
                return TSObjType.ARRAY;
            }
            else if (/^\+.+$/.test(ternDef)) {
                return TSObjType.CLASS;
            }
            else if (ternDef != "") {
                //console.log(`\u001b[35mWARNING: \u001b[0m ${ternDef} may not be type string. Is this a Object?`);
                return TSObjType.OBJECT;
            }
            else {
                throw Error("\u001b[31mcan not check type. : \u001b[0m" + ternDef);
                //return;
            }
        };
        DTSMake.prototype.splitUnions = function (ternDef) {
            return this.splits(ternDef, "(", ")", "|");
        };
        DTSMake.prototype.splitParams = function (paramStr) {
            return this.splits(paramStr, "(", ")", ",");
        };
        DTSMake.prototype.splitReturn = function (fnStr) {
            return this.splits(fnStr, "(", ")", "->");
        };
        DTSMake.prototype.splits = function (str, depthUpStr, depthDownStr, splitter) {
            var delimIdxs = [];
            var retStr = [];
            var len = str.length | 0;
            var depth = 0;
            //*
            var dUpIni = depthUpStr.charAt(0);
            var dDwIni = depthDownStr.charAt(0);
            var splIni = splitter.charAt(0);
            for (var i = 0 | 0; (i | 0) < (len | 0); i = (i + 1) | 0) {
                var cs = str.charAt(i);
                switch (cs) {
                    case dUpIni:
                        depth++;
                        break;
                    case dDwIni:
                        depth--;
                        break;
                    case splIni:
                        if (str.substr(i, splitter.length) != splitter)
                            break;
                        if (depth === 0) {
                            delimIdxs.push(i);
                            i += splitter.length;
                        }
                        break;
                    default:
                        break;
                }
            } //*/
            var delimLen = delimIdxs.length;
            if (delimLen === 0) {
                retStr.push(str);
            }
            else {
                var start = 0;
                var end = 0;
                for (var j = 0; j < delimLen; j++) {
                    end = delimIdxs[j];
                    var s = str.slice(start, end);
                    start = delimIdxs[j] + splitter.length;
                    retStr.push(s);
                    if (j == delimLen - 1) {
                        retStr.push(str.slice(start));
                    }
                }
            }
            //console.log(`retStr:${retStr}`);
            return retStr;
        };
        return DTSMake;
    }());
    dtsmake.DTSMake = DTSMake;
    var ReplaceType;
    (function (ReplaceType) {
        ReplaceType[ReplaceType["RETURN"] = 0] = "RETURN";
        ReplaceType[ReplaceType["PARAM"] = 1] = "PARAM";
        ReplaceType[ReplaceType["CLASS"] = 2] = "CLASS";
        ReplaceType[ReplaceType["ARRAY"] = 3] = "ARRAY";
        ReplaceType[ReplaceType["OTHER"] = 4] = "OTHER";
    })(ReplaceType = dtsmake.ReplaceType || (dtsmake.ReplaceType = {}));
    var TSObjType;
    (function (TSObjType) {
        TSObjType[TSObjType["ANY"] = 0] = "ANY";
        TSObjType[TSObjType["VOID"] = 1] = "VOID";
        TSObjType[TSObjType["BOOLEAN"] = 2] = "BOOLEAN";
        TSObjType[TSObjType["NUMBER"] = 3] = "NUMBER";
        TSObjType[TSObjType["STRING"] = 4] = "STRING";
        TSObjType[TSObjType["FUNCTION"] = 5] = "FUNCTION";
        TSObjType[TSObjType["ARRAY"] = 6] = "ARRAY";
        TSObjType[TSObjType["CLASS"] = 7] = "CLASS";
        TSObjType[TSObjType["UNIONS"] = 8] = "UNIONS";
        TSObjType[TSObjType["OBJECT"] = 9] = "OBJECT";
    })(TSObjType = dtsmake.TSObjType || (dtsmake.TSObjType = {}));
})(dtsmake = exports.dtsmake || (exports.dtsmake = {}));
(function (dtsmake) {
    var DTSDef;
    (function (DTSDef) {
        DTSDef.NEW = "new ";
    })(DTSDef = dtsmake.DTSDef || (dtsmake.DTSDef = {}));
})(dtsmake = exports.dtsmake || (exports.dtsmake = {}));
(function (dtsmake) {
    var TSObj;
    (function (TSObj) {
        var Def;
        (function (Def) {
            Def.TYPE = "type";
            Def.NAME = "name";
            Def.PARAMS = "params";
            Def.RET = "ret";
            Def.ARRAYTYPE = "arrayType";
            Def.CLASS = "class";
        })(Def = TSObj.Def || (TSObj.Def = {}));
    })(TSObj = dtsmake.TSObj || (dtsmake.TSObj = {}));
})(dtsmake = exports.dtsmake || (exports.dtsmake = {}));
(function (dtsmake) {
    var Option;
    (function (Option) {
        var ExportStyle;
        (function (ExportStyle) {
            /**
             * es6 style `export default MODULE;`
             */
            ExportStyle.ES6 = "es6";
            /**
             * legacy ts style `export = MODULE;`
             */
            ExportStyle.LEGACY = "legacy";
        })(ExportStyle = Option.ExportStyle || (Option.ExportStyle = {}));
    })(Option = dtsmake.Option || (dtsmake.Option = {}));
})(dtsmake = exports.dtsmake || (exports.dtsmake = {}));
(function (dtsmake) {
    var Option;
    (function (Option) {
        var GlobalObject;
        (function (GlobalObject) {
            /**
             * remove extending global objects, no output
             */
            GlobalObject.REMOVE = "remove";
            /**
             * wraping global objects with lib's namespace
             * @example `Math` -> `lib.Math`
             */
            GlobalObject.WRAP = "wrap";
            /**
             * renaming global objects
             * @example `Math` -> `Lib$Math`
             */
            GlobalObject.RENAME = "rename";
            /**
             * renaming global objects and extending global object
             * @example `Math` -> `Lib$Math extends Math`
             * [NEED] tsc >= 1.6
             */
            GlobalObject.RENAME_EXTEND = "renameExtend";
        })(GlobalObject = Option.GlobalObject || (Option.GlobalObject = {}));
    })(Option = dtsmake.Option || (dtsmake.Option = {}));
})(dtsmake = exports.dtsmake || (exports.dtsmake = {}));
(function (dtsmake) {
    var TernDef;
    (function (TernDef) {
        TernDef.NAME = "!name";
        TernDef.DEFINE = "!define";
        TernDef.TYPE = "!type";
        TernDef.DOC = "!doc";
        TernDef.URL = "!url";
        TernDef.EFFECTS = "!effects";
        TernDef.THIS = "!this";
        TernDef.RET = "!ret";
        TernDef.SPAN = "!span";
        TernDef.PROTO = "!proto";
        TernDef.STR_PROTO = "!stdProto";
        TernDef.NODE = "!modules";
        /**
         * convert TernDef.CONST:string to EnumTernDef.CONST:number
         * @param s TernDef class prop constraint string
         * @return EnumTernDef enum
         */
        function strToEnum(s) {
            switch (s) {
                case this.NAME: return 0 /* NAME */; //break;
                case this.DEFINE: return 1 /* DEFINE */; //break;
                case this.TYPE: return 2 /* TYPE */; //break;
                case this.DOC: return 3 /* DOC */; //break;
                case this.URL: return 4 /* URL */; //break;
                case this.EFFECTS: return 5 /* EFFECTS */; //break;
                case this.THIS: return 6 /* THIS */; //break;
                case this.RET: return 7 /* RET */; //break;
                case this.SPAN: return 8 /* SPAN */; //break;
                case this.PROTO: return 9 /* PROTO */; //break;
                case this.STD_PROTO: return 10 /* STR_PROTO */; //break;
                case this.NODE: return 11 /* NODE */; //break;
                default:
                    throw Error("no match enum strings:" + s);
            }
        }
        TernDef.strToEnum = strToEnum;
    })(TernDef = dtsmake.TernDef || (dtsmake.TernDef = {}));
})(dtsmake = exports.dtsmake || (exports.dtsmake = {}));
///////////////////////////////
// CLI 
//////////////////////////////
//var dgen = new dtsmake.DTSMake();
